import{_ as a,c as t,o,a4 as e}from"./chunks/framework.CUMjAKNJ.js";const r="/yzp-blog/assets/%E6%88%98%E6%9C%AF%E3%80%81%E6%88%98%E7%95%A5%E7%BC%96%E7%A8%8B.CAmO024D.png",p="/yzp-blog/assets/%E9%BB%84%E9%87%91%E5%9C%88.CBKoCynY.png",s="/yzp-blog/assets/%E5%9C%9F%E6%B3%95%E7%82%BC%E9%92%A2.BTVttd7j.png",m=JSON.parse('{"title":"浅谈代码复杂度的困局","description":"","frontmatter":{},"headers":[],"relativePath":"工作点滴积累/浅谈系列/浅谈代码复杂度的困局.md","filePath":"工作点滴积累/浅谈系列/浅谈代码复杂度的困局.md"}'),l={name:"工作点滴积累/浅谈系列/浅谈代码复杂度的困局.md"},n=e('<h1 id="浅谈代码复杂度的困局" tabindex="-1">浅谈代码复杂度的困局 <a class="header-anchor" href="#浅谈代码复杂度的困局" aria-label="Permalink to &quot;浅谈代码复杂度的困局&quot;">​</a></h1><h2 id="🍉写在前面的话" tabindex="-1">🍉写在前面的话 <a class="header-anchor" href="#🍉写在前面的话" aria-label="Permalink to &quot;🍉写在前面的话&quot;">​</a></h2><p>在日常工作中，经常需要维护一些其他同事开发的模块代码。看到优秀的实现逻辑，会让人感到“酣畅淋漓”；遇到错综复杂的代码结构，也会让人&quot;垂头丧气&quot;。不过我好像总是遇到后者（苦笑）。</p><p>当然造成这种困局的缘由多种多样：实际项目中“时间紧，任务重”的客观因素；一些团队推崇“完成就好”的战术编程思想；个体之间编程习惯差异导致的主观不适感。假如抛开以上这些主/客观原因，直面目前存在的代码复杂度高、质量令人堪忧的现状，那么有什么办法去突破困局呢？</p><p>我尝试用一种很通俗易懂的方式来解释这件事情，希望你们能够理解以及体会。</p><h2 id="🍋快速了解代码复杂度" tabindex="-1">🍋快速了解代码复杂度 <a class="header-anchor" href="#🍋快速了解代码复杂度" aria-label="Permalink to &quot;🍋快速了解代码复杂度&quot;">​</a></h2><h3 id="什么是代码复杂度" tabindex="-1">什么是代码复杂度 <a class="header-anchor" href="#什么是代码复杂度" aria-label="Permalink to &quot;什么是代码复杂度&quot;">​</a></h3><p>我理解所谓的代码复杂度分为：<strong>静态代码复杂度</strong>和<strong>动态代码复杂度</strong>。</p><p>静态代码复杂度是衡量问题规模与编码量关系的标准；动态代码复杂度是衡量程序求解问题与时间、空间关系的标准。虽然静态代码复杂度和动态代码复杂度之间不存在必然联系，但是从从某种意义上来说，静态代码复杂度较高，一定程度上会导致动态代码复杂度变高。</p><p>接下来简单介绍下两种代码复杂度（下文笼统的把两种代码复杂度简称为“复杂度”）。</p><h3 id="静态代码复杂度" tabindex="-1">静态代码复杂度 <a class="header-anchor" href="#静态代码复杂度" aria-label="Permalink to &quot;静态代码复杂度&quot;">​</a></h3><p>静态代码复杂度，即通过肉眼观察类或者方法逻辑代码量和逻辑结构，可以直观的看出代码的“繁”和“简”，或者通过命名方式和代码注释，到底是“通俗易懂”，还是“一头雾水”。</p><p>而降低静态代码复杂度通俗来讲就是：编写更少的代码以实现功能，这样可以提高开发效率，节约软件开发成本。即用低编码量去实现同一个功能逻辑。</p><h3 id="动态代码复杂度" tabindex="-1">动态代码复杂度 <a class="header-anchor" href="#动态代码复杂度" aria-label="Permalink to &quot;动态代码复杂度&quot;">​</a></h3><p>动态代码复杂度，即需要通过运行代码的方式进行判定，一般的判断依据是”快“或“慢”，“省”或”费“的问题。</p><p>“快慢”即描述代码算法运行的时间长短，“省费”是描述代码运行过程中所需使用的内存大小。也就是说，衡量代码执行效率高低，主要有两个维度，时间、空间复杂度。</p><p>所以降低动态代码复杂度即：实现同一功能，使程序运行速度更快，占用的内存空间更小。</p><blockquote><p><strong>📌 知识拓展</strong></p><p>时间复杂度：时间复杂度全称是渐进式时间复杂度(asymptotic time complexity)，用来表示代码执行随着数据规模增长，当前算法所消耗的时间变化趋势。</p><p>空间复杂度：空间复杂度的全称是渐进式空间复杂度(asymptotic space complexity)，用来表示代码执行随着数据规模增长，当前算法所消耗的内存空间变化趋势。</p></blockquote><h2 id="🍒导致复杂度的原因" tabindex="-1">🍒导致复杂度的原因 <a class="header-anchor" href="#🍒导致复杂度的原因" aria-label="Permalink to &quot;🍒导致复杂度的原因&quot;">​</a></h2><h3 id="战术编程思维导致-雪球效应" tabindex="-1">战术编程思维导致“雪球效应” <a class="header-anchor" href="#战术编程思维导致-雪球效应" aria-label="Permalink to &quot;战术编程思维导致“雪球效应”&quot;">​</a></h3><p><img src="'+r+'" alt="战术、战略编程"></p><blockquote><p><strong>📌 知识拓展</strong></p><p>战术编程：要求以最快的速度完成可工作的功能，这种行为往往会增加系统的复杂性，引发大量的技术债。</p><p>战略编程：不仅仅要求可工作的代码，以好的设计为重，未来的功能投资，认为现阶段在设计上的投入会在将来获得回报。</p></blockquote><p>大多数程序员使用一种称为“战术编程”的思维方式来进行软件开发。在战术方法中，主要关注点是让功能以最快的方式工作起来，比如一个新特性或一个 bug 修复。乍一看，这似乎完全合理：用最高效的方式交付一个功能快速抢占市场，有什么比这个更重要呢？</p><p>不过，战术编程几乎不可能产生一个良好的系统设计。所以在我看来，战术编程在一些小型定制项目上面的优势毋庸置疑。但是针对基线产品的开发或者是一些重大项目的迭代开发过程中依然采用此方法，或许会得不偿失。</p><p>一个产品经过不断的版本迭代以满足市场以及用户需求，<em>战术编程带来的代码复杂度自然而然也像滚雪球一样越滚越大，带来的风险也越来越高</em>。随着产品的批量交付，各种定制以及现场问题的接踵而至，让原本看似高效的开发模式，最后付出“惨重”的运维代价。</p><h3 id="思路不清晰导致-简单问题复杂化" tabindex="-1">思路不清晰导致“简单问题复杂化” <a class="header-anchor" href="#思路不清晰导致-简单问题复杂化" aria-label="Permalink to &quot;思路不清晰导致“简单问题复杂化”&quot;">​</a></h3><p><img src="'+p+'" alt="黄金圈"></p><p>大部分人都知道，由“为什么（Why）”，“怎么做(How)”和“做什么(What)”这三者所组成的同心圆，称之为“黄金圈”（Golden Circle）。</p><p>在工作中，“做什么”是大多数开发人员首先会关心的事情。但是在实际解决问题的过程中，很少花时间去思考“怎么做”和“为什么”。甚至很多盆友本着“简单问题复杂化，没有困难制造困难”的原则，硬生生把两位数量级的代码量，活生生写成了三位数甚至四位数量级的代码量。</p><p>举个栗子：比如你接到一个定制需求，对接第三方系统接入数据，然后领导丢给你一个API文档，你对照着文档哼哧哼哧开发完了几十个接口后，最后被告知说实际业务只用到了其中的一两个接口而已。</p><p>当然这个例子可能不是特别恰当，但是希望你能理解我想表达的另外一层意思：假如把其中的接口理解成程序的复杂度，是不是有时候我们因为没有捋清怎么做和为什么做，导致把原本简单问题复杂化了呢。</p><h3 id="土法炼钢-式编程导致-低内聚-高耦合" tabindex="-1">“土法炼钢”式编程导致&quot;低内聚，高耦合&quot; <a class="header-anchor" href="#土法炼钢-式编程导致-低内聚-高耦合" aria-label="Permalink to &quot;“土法炼钢”式编程导致&quot;低内聚，高耦合&quot;&quot;">​</a></h3><blockquote><p><strong>📌 特别声明</strong></p><p>下图仅为直观展现土法炼钢场景，无任何政治倾向及不良引导。</p></blockquote><p><img src="'+s+'" alt="土法炼钢"></p><p>上面提到的战术编程主要是从思维和决策角度讨论，而这里提到的“土法炼钢”式编程指的就是实际编程人员在日常工作中的编程习惯或者技术技能问题。接下来大概解释一下什么是“内聚”，什么是“耦合”。</p><p><strong>什么是耦合</strong></p><p>耦合就是元素与元素之间的连接，感知和依赖量度。这里说的元素即是功能，对象，系统，子系统。模块。</p><p>例如：现在有方法A和方法B，我们在A元素去调用B元素，当B元素有问题或者不存在的时候，A元素就不能正常的工作，那么就说元素A和元素B耦合。</p><p>当元素B变更或者不存在时，都将影响元素A的正常运作，影响系统的可维护性和易变更性。同时元素A只能运行在元素B中，这也大大的降低了A元素的可复用性。正因为耦合的种种弊端，我们才需要在软件设计上追求低耦合。</p><p><strong>什么是内聚</strong></p><p>内聚是另外一个评判软件设计质量的标准。内聚更为专业的说法叫做功能内聚，是对系统中元素职责的相关性和集中度的量度。如果元素有高度的相关职责，除了这些职责在没有其他的工作，那么该元素就有高内聚。</p><p>例如：在一个项目集工作中，我是一个项目经理，我的职责是监控和协调我的项目各个阶段的工作。当我的项目进入需求分析阶段，我会请求需求分析员来完成；当我的项目进入开发阶段，我会请求软件开发人员来完成；当我的项目需要测试的时候，我会请求测试人员。</p><p>如果我参与了编码开发，我就不是一个高内聚的元素，因为开发并不是我的职责。当然这个例子只是为了解释程序的内聚问题，“人之才，成于专而毁于杂”，程序也是如此。</p><p><strong>什么是&quot;土法炼钢式&quot;编程</strong></p><p>比如我们需要开发一个接收、解析报警事件，并且保存入库的功能。同事X将所有的逻辑通过一个类或者一个方法实现了，洋洋洒洒几千行代码，并且运行起来也确实实现了事件A的入库需求。如果是你来开发，你打算怎么设计开发呢？</p><p>当然我们很难从“对或错”的角度去评价这件事，因为它确确实实实现了需要的功能。但是当事件A的报文发生了一些改动，或者解析的流程需要做出调整，或者需要再对接一个同样逻辑的事件B，在实际项目中这些变化都普遍的。</p><p>发生这些变化的时候，想想你的代码需要需要修改几个地方呢？如果只是加个配置，修改几个接口，或者加个实现类就能实现事件B的接入，那么你开发的代码结构就是&quot;高内聚，低耦合&quot;的；如果你需要改动很多地方，牵一发而动全身，甚至于推翻重写，那么显而易见这是&quot;低内聚，高耦合&quot;的表现。很显然，同事X将所有逻辑写在一个方法中的方式属于后者。</p><h2 id="🍐如何避免复杂度问题的思考" tabindex="-1">🍐如何避免复杂度问题的思考 <a class="header-anchor" href="#🍐如何避免复杂度问题的思考" aria-label="Permalink to &quot;🍐如何避免复杂度问题的思考&quot;">​</a></h2><h3 id="战略为主-战术为辅" tabindex="-1">&quot;战略为主，战术为辅&quot; <a class="header-anchor" href="#战略为主-战术为辅" aria-label="Permalink to &quot;&quot;战略为主，战术为辅&quot;&quot;">​</a></h3><p>在日常工作中，面对的项目林林总总，从决策角度也不能笼统的决定采用战略或者战术，而应该结合实际的项目情况进行考虑，大概总结的几种场景如下：</p><ul><li>小打小闹的<strong>定制开发</strong>或者简单增删改查模块，从“性价比”的角度来说，优先考虑采用战术编程方式实现；</li><li><strong>重点项目</strong>往往面临需求变更频繁、开发周期短等问题，所以综合考虑通过战略编程的思维进行设计，保证程序整体的可延续性和扩展性；然后进行战术实现，优先考虑交付可用的功能；</li><li><strong>基线产品</strong>设计开发过程中，应该充分运用战略设计和战略编程，降低代码复杂度，便于后期运维及迭代升级；</li></ul><p>短期来看战略编程的成本会高于战术编程，但是从长期来看，保持“战略”的成本是值得的，它能够有效的降低系统的复杂度，从而最终能降低后续投入的成本。</p><h3 id="三思而行-行而再思" tabindex="-1">&quot;三思而行，行而再思&quot; <a class="header-anchor" href="#三思而行-行而再思" aria-label="Permalink to &quot;&quot;三思而行，行而再思&quot;&quot;">​</a></h3><p>”三思“即“为什么（Why）”，“怎么做(How)”和“做什么(What)”。</p><p>当我们接到一个项目需求，或者是一个产品的模块开发需求时候。作为一名研发人员，会进行必要的需求分析以及概要设计（详细设计）工作，但是除了了解“做什么”和“怎么做”以外。是否应该多想一些“为什么”的问题呢？</p><p>&quot;为什么会有这个项目？为什么需要这样的产品？我开发的东西会用在哪里，怎么用？&quot;。我始终深信一个开发人员需要知道和思考这些“为什么“。只有当你知道这些后，你才能做出最优的解决问题方案，开发出更有价值的产品。但是在实际工作中，又有几个小伙伴如此“扪心自问”过呢？</p><p>另外关于“行而再思”即理解为复盘总结，完成一个工作之后，从另外一个角度再去看“三思”的问题，对项目和产品会有更深一层次的理解和思考，肯定也会有不一样的感受和收获。</p><h3 id="打铁还需自身硬-不须扬鞭自奋蹄" tabindex="-1">&quot;打铁还需自身硬，不须扬鞭自奋蹄&quot; <a class="header-anchor" href="#打铁还需自身硬-不须扬鞭自奋蹄" aria-label="Permalink to &quot;&quot;打铁还需自身硬，不须扬鞭自奋蹄&quot;&quot;">​</a></h3><p>当你搞清楚以上两个问题，对于一个研发人员而言，最终一定会回归到技术本身。</p><p>在我看来，一个功能模块的实现肯定不是简单的代码堆叠。比如我们设计实现一个增删改查的功能，需要考虑程序模块的可重用性、移植性；模块的职责划分，控制层、服务层、数据层的接口设计；接口对象的校验，参数定义及继承关系；通俗易懂的代码注册，让人能够一目了然的理解接口含义等等问题。哪怕是一个看似很简单的功能，我们也可以做很多事情，而不仅仅是写两三行代码的问题。</p><p>只有当我们能够把一些简单的技术问题解决妥当，养成较好的编程习惯或者在工作点滴间提高了技术技能，那么面对一些复杂需求才能更加游刃有余吧。</p><h2 id="🍈参考资料" tabindex="-1">🍈参考资料 <a class="header-anchor" href="#🍈参考资料" aria-label="Permalink to &quot;🍈参考资料&quot;">​</a></h2><ul><li>软件设计的哲学（A Philosophy of Software Design）</li><li><a href="https://zhuanlan.zhihu.com/p/551028090" target="_blank" rel="noreferrer">「黄金圈」有啥用？</a><sup>知乎</sup></li><li><a href="https://blog.csdn.net/cocos2dGirl/article/details/110469242" target="_blank" rel="noreferrer">代码复杂度分析</a><sup>CSDN</sup></li></ul><h2 id="🍌写在最后面的话" tabindex="-1">🍌写在最后面的话 <a class="header-anchor" href="#🍌写在最后面的话" aria-label="Permalink to &quot;🍌写在最后面的话&quot;">​</a></h2><p>有的人觉得写业务代码是一件很Low逼的事情，不过是一堆 if-else而已，何必那么认真；或者“教训是深刻的，反思是敷衍的”，反正最后态度我就是这么干，爱谁谁优化就谁谁优化去吧。也正是因为存在这种认知的差别，让我们总觉得身陷困局，但是这些困扰的本质上或许正是来自于你自己。</p><p>一篇很浅显的代码复杂度讨论分享文章，不过是抛砖引玉，希望能够引起大家的思考罢了。</p><p>祝你好运🎉，盆友~<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>“如果大家一起奔跑，世界将变得更美好。”---created by 袁志鹏 on 四月 21,2023；last edited by 袁志鹏 on 六月 12,2023 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>',69),i=[n];function h(c,u,d,q,b,f){return o(),t("div",null,i)}const g=a(l,[["render",h]]);export{m as __pageData,g as default};
